# Packages
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.integrate import quad 
import os
from scipy.interpolate import make_interp_spline
from scipy.optimize import curve_fit
import argparse
import time
# Modification of one of Lindsay Goulet code

# ---------------------------------------
# ---------- Goal of this file ----------
# ---------------------------------------
# The goal of this file is to exploit the dadi and stairway results we have
# And represent them to better compare them

# ---------------------------------------
original_dir = os.getcwd()

parser = argparse.ArgumentParser()
parser.add_argument('--path_stair_data', type=str, required=True)
parser.add_argument('--path_dadi_data', type=str, required=True)
parser.add_argument('--path_stair_inf_params', type=str, required=True)
parser.add_argument('--path_dadi_inf_params', type=str, required=True)

parser.add_argument('--event_ratio', type=float, required=True) # ratio of the event (< 1 if reduction, > 1 if expansion)
parser.add_argument('--nbr_generation', type=int, required=True) # number of generation used in the simulation
parser.add_argument('--T_theo', type=float, required=True) # Theorical start of the event (T) (en générations ago)
parser.add_argument('--Ninit', type=int, required=True) # Initial popsize

parser.add_argument('--simu_type', type=str, required=True)
args = parser.parse_args()

path_stair_data = args.path_stair_data # Path to the csv file containing the coordinates for each points simulated (x : time, y : popsize) for Stairway
path_dadi_data = args.path_dadi_data # Path to the csv file containing the coordinates for each points simulated (x : time, y : popsize) for dadi
path_stair_inf_params = args.path_stair_inf_params # Path to the csv file containing the infered parameters T and Nu for Stairway
path_dadi_inf_params = args.path_dadi_inf_params # Path to the csv file containing the infered parameters T and Nu for Dadi
type_simu = args.simu_type # String containing the simulation type (expansion_neutral for example)

# Inferred params recuperation
T_inf_stair_tot = [-1, -1, -1, -1]
Nu_inf_stair_tot = [-1, -1, -1, -1]


for filename in sorted(os.listdir(path_stair_inf_params)):
    filepath = os.path.join(path_stair_inf_params, filename)
    print("Filepath : ", filepath)
    if ( (type_simu in filepath)  ) :
        print("hzefbnejvn ", filepath)
        if (str(100) in filepath) : 
            if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                df = pd.read_csv(filepath) 
                T_inf_stair_tot[3] =(float(df['T'][0]) )  # The infered parameters for stairway
                Nu_inf_stair_tot[3] = ( float(df['Nu'][0]) )
        else :
            if (str(50) in filepath) : 
                if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                    df = pd.read_csv(filepath) 
                    T_inf_stair_tot[2] =(float(df['T'][0]) )  # The infered parameters for stairway
                    Nu_inf_stair_tot[2] = ( float(df['Nu'][0]) )
            else :
                if (str(10) in filepath) : 
                    if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                        df = pd.read_csv(filepath) 
                        T_inf_stair_tot[1] =(float(df['T'][0]) )  # The infered parameters for stairway
                        Nu_inf_stair_tot[1] = ( float(df['Nu'][0]) )
                else : 
                    if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                        df = pd.read_csv(filepath) 
                        T_inf_stair_tot[0] =(float(df['T'][0]) )  # The infered parameters for stairway
                        Nu_inf_stair_tot[0] = ( float(df['Nu'][0]) )


T_inf_dadi_tot = [-1, -1, -1, -1]
Nu_inf_dadi_tot = [-1, -1, -1, -1]

for filename in sorted(os.listdir(path_dadi_inf_params)):
    filepath = os.path.join(path_dadi_inf_params, filename)
    print("Filepath : ", filepath)
    if ( (type_simu in filepath)  ) :
        if (str(100) in filepath) : 
            if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                df = pd.read_csv(filepath) 
                T_inf_dadi_tot[3] =(float(df['T'][0]) )  # The infered parameters for stairway
                Nu_inf_dadi_tot[3] = ( float(df['Nu'][0]) )
        else :
            if (str(50) in filepath) : 
                if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                    df = pd.read_csv(filepath) 
                    T_inf_dadi_tot[2] =(float(df['T'][0]) )  # The infered parameters for stairway
                    Nu_inf_dadi_tot[2] = ( float(df['Nu'][0]) )
            else :
                if (str(10) in filepath) : 
                    if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                        df = pd.read_csv(filepath) 
                        T_inf_dadi_tot[1] =(float(df['T'][0]) )  # The infered parameters for stairway
                        Nu_inf_dadi_tot[1] = ( float(df['Nu'][0]) )
                else : 
                    if os.path.isfile(filepath):  # makes sure it's a file, not a folder
                        df = pd.read_csv(filepath) 
                        T_inf_dadi_tot[0] =(float(df['T'][0]) )  # The infered parameters for stairway
                        Nu_inf_dadi_tot[0] = ( float(df['Nu'][0]) )



 
# True values mean
Ne = args.Ninit # Initial popsize
nu = args.event_ratio
T = args.T_theo / (2 * Ne)
Nbr_gen = args.nbr_generation

t1 = np.linspace(0, Nbr_gen) # all the generations simulated


# ---------------------------------------
# ---------------------------------------

# Lindsay's Functions --( headers and comments added later on by Lénora, may be wrong )-------------------------
def moy(L) : #fait la moyenne : L = [[1, 2], [3, 4]] -> M = [2, 3]
    """ Mean of a list of lists 
    @param : L, list of lists
    @return : list of the means for each indices troughout all the elements of the given list
    """
    M = []
    for i in range(0, len(L[0])) :
        m = 0
        for j in range(0, len(L)):
            m += L[j][i]
        m = m/len(L)
        M.append(m)
    return M
    
def fonction_moyenne(dir, GR, t):
    """ Mean of a function 
    @param : dir, a directory where some csv files are located (format : x,y the coordinates of the function)
             t, time ?? # to check
    @return : moy(M), mean of the interpolating B-spline for t  # to check
              nb_rep, the numbers of files (of repetitions)
    """
    os.chdir(dir)
    file = os.listdir()
    M = []
    nb_rep = 0
    liste_file = [ f for f in file if (".csv" in f) and (type_simu in f) and ( (str(GR) +".") in f)]
    print("Liste fichiers ----------------- : ", liste_file)
    for f in liste_file :
        print(f)
        if (".csv" in f) and (type_simu in f): #pour chaque csv du répertoire
            nb_rep += 1
            print(f)
            df = pd.read_csv(f, sep=",")
            X = df['x']
            X = [x for x in X if np.isnan(x) == False]
            Y = df['y']
            f = make_interp_spline(X, Y, k=1)
            y = f(t)
            M.append(y) 
    return moy(M), nb_rep

    
def f_att_tepoch(time, Ni, T, nu) : # to check
    """ Theorical t epoch model 
    @param : time, list of generations ?
             Ni, initial population ?
             T, start of the expansion
             nu, ratio between Ninit and Nfinal
    @return : res, list of the population size trough time
    """
    res = []
    for t in time:
        if t >= T :
            res.append(Ni)
        else :
            res.append(Ni*nu)
    return res 

def f_att_expo(time, Ne, T, nu) :
    """ Theorical expansion model 
    @param : time, list of generations ?
             Ne, initial population
             T, start of the expansion
             nu, ratio between Ninit and Nfinal
    @return : res, list of the population size trough time
    """
    res = []
    #beta = np.log(nu)/T
    for t in time:
        if t >= T : # if before the start of the expansion, the pop size is constant
            res.append(Ne)
        else : # during the expansion
            res.append(Ne * np.exp(np.log(nu)/T*(T-t))) # to check
    return res 


def f_att_reduc(time, Ne, T, nu) :
    """ Theorical reduction model 
    @param : time, list of generations ?
             Ne, initial population
             T, start of the expansion
             nu, ratio between Ninit and Nfinal
    @return : res, list of the population size trough time
    """
    res = []
    #beta = np.log(nu)/T
    for t in time:
        if t >= T : # if before the start of the expansion, the pop size is constant
            res.append(Ne)
        else : # during the expansion
            res.append(Ne * nu)
    return res 

def f_att_const(time, Ne, T, nu) :
    """ Theorical constant model 
    @param : time, list of generations ?
             Ne, initial population
             T, start of the event
             nu, ratio between Ninit and Nfinal
    @return : res, list of the population size trough time
    """
    return Ne+0*time 

def erreur_fonction_moyenne(dir, GR, t, Ne, T, nu, f_att, nb_gen):
    """ Error mean function 
    @param : dir, a directory where some csv files are located (format : x,y the coordinates of the function)
             t, time ?? # to check
             Ne, initial pop size
             T, start of the event (popsize change)
             nu, ratio Nfinal / Ninitial
             f_att, function that returns the theorical values of the model with these parameters
             nb_gen, the number of generations simulated
    @return : d, the irse ???? # to check
              nb_rep, the number of repetitions
    """
    Y_moy, nb_rep = fonction_moyenne(dir, GR, t)

    def difference(t, Ne, T, nu):
        """ The difference between the calculated values and the theorical ones
        @param : t, time ?? # to check
                 Ne, initial pop size
                 T, start of the event (popsize change)
                 nu, ratio Nfinal / Ninitial
        @return : Y, list of the difference between the calculated values and the theorical ones
        """
        Y = []
        for i in range(len(Y_moy)):
            Y.append((f_att(t, Ne, T, nu)[i]-Y_moy[i])**2/f_att(t, Ne, T, nu)[i]**2)
        return Y

    Y = difference(t, Ne, T, nu)
    dif = make_interp_spline(t, Y, k=1)
    
    d = quad(dif, t[0], t[-1])[0]/nb_gen
    return d, nb_rep
# -----------------------------------------------------------------------------------------

# ---------------------------------------------------------------
# ---------------------------- IRSE ----------------------------
# ---------------------------------------------------------------

# We calcultate the IRSE (define by Lindsay) for the Stairway and Dadi results
IRSE_stair = []
IRSE_dadi = []
for GR in [1, 10, 50, 100] : # modify
    if 'expansion' in type_simu :
        stair, nb_stair = erreur_fonction_moyenne(path_stair_data, GR,  t1, Ne, T, nu ,f_att_expo, Nbr_gen)
        print("Stair : ", stair)
        os.chdir(original_dir)
        IRSE_stair.append(stair)

        dadi, nb_dadi = erreur_fonction_moyenne(path_dadi_data, GR, t1, Ne, T, nu ,f_att_expo, Nbr_gen)
        print("Dadi : ", dadi)
        os.chdir(original_dir)
        IRSE_dadi.append(dadi)
    else :
        if 'reduction' in type_simu :
            stair, nb_stair = erreur_fonction_moyenne(path_stair_data, GR, t1, Ne, T, nu ,f_att_reduc, Nbr_gen)
            print("Stair : ", stair)
            os.chdir(original_dir)
            IRSE_stair.append(stair)
        
            dadi, nb_dadi = erreur_fonction_moyenne(path_dadi_data, GR, t1, Ne, T, nu ,f_att_reduc, Nbr_gen)
            print("Dadi : ", dadi)
            os.chdir(original_dir)
            IRSE_dadi.append(dadi)   
        else :
            stair, nb_stair = erreur_fonction_moyenne(path_stair_data, GR, t1, Ne, T, nu ,f_att_const, Nbr_gen)
            print("Stair : ", stair)
            os.chdir(original_dir)
            IRSE_stair.append(stair)
        
            dadi, nb_dadi = erreur_fonction_moyenne(path_dadi_data, GR, t1, Ne, T, nu ,f_att_const, Nbr_gen)
            print("Dadi : ", dadi)
            os.chdir(original_dir)
            IRSE_dadi.append(dadi)  

# ---------------------------------------------------------------
# ---------------------------- PLOTS ----------------------------
# ---------------------------------------------------------------
print("Dadi irse")
print(IRSE_dadi)
print("Stair irse")
print(IRSE_stair)

"""
fig, ax = plt.subplots(1, 3, figsize=(10, 4))
BoxName = ['stair', 'dadi']

# Bar plot with one bar
ax[0].bar([0, 1], [IRSE_dadi, IRSE_dadi], color=['burlywood'])
ax[0].set_xticks([0, 1])
ax[0].set_xticklabels(BoxName)
ax[0].set_title('ISRE', fontsize=14)
ax[0].set_ylabel('ISRE', fontsize=12)
plt.show()

# Boxplot with one box
# ax1 for nu Estimation
Nu_estime = [ [Nu_inf_stair_tot], [Nu_inf_dadi_tot]] # for every repetition
bplot = ax[1].boxplot(Nu_estime, patch_artist=True)
bplot['boxes'][0].set_facecolor('burlywood')
bplot['medians'][0].set_color('saddlebrown')


ax[1].set_xticklabels(BoxName, fontsize=12)
ax[1].axhline(nu, alpha=0.75, c='crimson', ls='--', label='valeur réelle')
ax[1].legend(fontsize=12)
ax[1].set_title("Estimation de Nu", fontsize=14)


# ax2 for T Estimation
T_estime = [ [T_inf_stair_tot], [T_inf_dadi_tot] ] # for every repetition
bplot = ax[2].boxplot(T_estime, patch_artist=True)
bplot['boxes'][0].set_facecolor('burlywood')
bplot['medians'][0].set_color('saddlebrown')

ax[2].set_xticklabels(BoxName, fontsize=12)
ax[2].axhline(T, alpha=0.75, c='crimson', ls='--', label='valeur réelle')
ax[2].legend(fontsize=12)
ax[2].set_title("Estimation de T", fontsize=14)

fig.savefig("../../results/boxplots/" + str(rep) + "/" +  type_simu + "_plots_" + str(time.time()) +".pdf")
#plt.show()

"""
# ------------------------------------------------------------------
# ---------------------- IRSE GR comparaison -----------------------
# ------------------------------------------------------------------


cats =  ['GR1', 'GR10', 'GR50', 'GR100'] 


# Bar width and x locations
w, x = 0.4, np.arange(len(cats))

fig, ax = plt.subplots()
ax.bar(x - w/2, IRSE_stair, width=w, label='Stairway results')
ax.bar(x + w/2, IRSE_dadi, width=w, label='Dadi results')

ax.set_xticks(x)
ax.set_xticklabels(cats)
ax.set_ylabel('IRSE')
ax.set_title('IRSE comparaison with different sexual reproduction frequency')
ax.legend()

plt.savefig("../../results/irse/" + "irse_comp_" + type_simu + "_" + str(time.time()) + ".pdf")     
#plt.show()





# ------------------------------------------------------------------
# ---------------------- Nu GR comparaison -----------------------
# ------------------------------------------------------------------

print("Nu dadi : ", Nu_inf_dadi_tot)
print("Nu stair : ", Nu_inf_stair_tot)

cats = ['GR1', 'GR10', 'GR50', 'GR100'] #, 'GR10', 'GR50', 'GR100'] # categories


# Bar width and x locations
w, x = 0.4, np.arange(len(cats))

fig, ax = plt.subplots()
ax.bar(x - w/2, Nu_inf_stair_tot, width=w, label='Stairway results')
ax.bar(x + w/2, Nu_inf_dadi_tot, width=w, label='Dadi results')

ax.set_xticks(x)
ax.set_xticklabels(cats)
ax.set_ylabel('Nu')
ax.set_title('Nu comparaison with different sexual reproduction frequency')
ax.legend()

plt.savefig("../../results/Nu/" + "Nu_prediction_comparaison_" + type_simu + "_" + str(time.time()) + ".pdf")     
#plt.show()



# ------------------------------------------------------------------
# ---------------------- T GR comparaison -----------------------
# ------------------------------------------------------------------
print("T dadi : ", T_inf_dadi_tot)
print("T stair : ", T_inf_stair_tot)

cats =  ['GR1', 'GR10', 'GR50', 'GR100'] #, 'GR10', 'GR50', 'GR100'] # categories


# Bar width and x locations
w, x = 0.4, np.arange(len(cats))

fig, ax = plt.subplots()
ax.bar(x - w/2, T_inf_stair_tot, width=w, label='Stairway results')
ax.bar(x + w/2, T_inf_dadi_tot, width=w, label='Dadi results')

ax.set_xticks(x)
ax.set_xticklabels(cats)
ax.set_ylabel('T')
ax.set_title('T comparaison with different sexual reproduction frequency')
ax.legend()

plt.savefig("../../results/T/" + "T_prediction_comparaison_" + type_simu + "_" + str(time.time()) + ".pdf")     
plt.show()